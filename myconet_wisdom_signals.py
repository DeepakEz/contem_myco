# -*- coding: utf-8 -*-
"""MycoNet++ Wisdom Signal System (Fully Implemented)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cltI64zOjp4HxSTWAjPfzF8Gkpf0dO8i
"""

"""
MycoNet++ Wisdom Signal System (Definitive, Self-Contained)
===========================================================

This script provides a complete, self-contained, and high-performance system
for simulating the propagation of "wisdom signals" through a 2D grid.
All previously placeholder classes (`WisdomType`, `WisdomInsight`) have been
fully implemented within this file, removing all external dependencies.

Key Features Implemented:
- Definitive Core Types: `WisdomType` and `WisdomInsight` are now fully
  fleshed-out classes, not placeholders.
- Agent-Level Processor: Includes the `WisdomSignalProcessor` for agent interaction
  with detailed sensitivities and responses.
- Network Analysis Tools: Includes methods to detect suffering areas and wisdom hotspots.
- Optimized Diffusion: Uses `scipy.signal.convolve2d` for high-performance,
  vectorized signal propagation.
- Configurable Interference: Signal interaction rules can be provided
  externally during initialization.
- Adaptive Decay: Signal decay rates can be modulated by environmental factors.
- Overmind Feedback Loop: A method allows a global controller to dynamically
  alter signal parameters.
- Robustness & Debugging: Includes insight content validation and an optional
  debug mode for detailed logging.
"""

import numpy as np
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field
from enum import Enum
import logging
from collections import defaultdict
from scipy.signal import convolve2d
import time

# Initialize logger
logger = logging.getLogger(__name__)

# =====================================================================
# DEFINITIVE CORE TYPES (No Longer Placeholders)
# =====================================================================

class WisdomType(Enum):
    """
    Definitive enumeration of the different categories of wisdom.
    Each type corresponds to a different kind of knowledge or insight
    that can be propagated through the network.
    """
    ETHICAL_JUDGEMENT = "ethical_judgement"
    PRACTICAL_SKILL = "practical_skill"
    PHILOSOPHICAL_CONCEPT = "philosophical_concept"
    EMPATHIC_RESONANCE = "empathic_resonance"
    SYSTEMIC_UNDERSTANDING = "systemic_understanding"

@dataclass
class WisdomInsight:
    """
    A definitive, self-contained data structure representing a single piece
    of wisdom. It includes validation to ensure content integrity.
    """
    wisdom_type: WisdomType
    content: Dict[str, Any]
    intensity: float
    source_agent_id: int
    timestamp: float = field(default_factory=time.time)

    def __post_init__(self):
        """Perform validation after the object is created."""
        self.validate_content()

    def validate_content(self):
        """
        Ensures the 'content' dictionary has the required keys for its
        specific WisdomType. This makes the data structure robust.
        """
        required_keys: Set[str] = set()
        if self.wisdom_type == WisdomType.ETHICAL_JUDGEMENT:
            required_keys = {'dilemma', 'judgement', 'justification'}
        elif self.wisdom_type == WisdomType.PRACTICAL_SKILL:
            required_keys = {'skill_name', 'steps', 'application'}
        elif self.wisdom_type == WisdomType.PHILOSOPHICAL_CONCEPT:
            required_keys = {'concept', 'explanation', 'implications'}
        elif self.wisdom_type == WisdomType.EMPATHIC_RESONANCE:
            required_keys = {'emotional_state', 'target_entity', 'context'}
        elif self.wisdom_type == WisdomType.SYSTEMIC_UNDERSTANDING:
            required_keys = {'system_name', 'key_relationships', 'leverage_points'}

        if not required_keys.issubset(self.content.keys()):
            missing = required_keys - set(self.content.keys())
            raise ValueError(
                f"Invalid content for {self.wisdom_type.value}. "
                f"Missing required keys: {missing}"
            )

    def __repr__(self) -> str:
        return (f"WisdomInsight(type={self.wisdom_type.name}, "
                f"intensity={self.intensity:.2f}, "
                f"source={self.source_agent_id})")


# =====================================================================
# SIGNAL SYSTEM CONFIGURATION AND ENUMERATIONS
# =====================================================================

class WisdomSignalType(Enum):
    """Types of wisdom signals that can propagate through the network"""
    ETHICAL_INSIGHT = "ethical_insight"
    SUFFERING_ALERT = "suffering_alert"
    COMPASSION_GRADIENT = "compassion_gradient"
    WISDOM_BEACON = "wisdom_beacon"
    MEDITATION_SYNC = "meditation_sync"
    COOPERATION_CALL = "cooperation_call"
    CAUTION_WARNING = "caution_warning"
    MINDFULNESS_WAVE = "mindfulness_wave"

@dataclass
class WisdomSignalConfig:
    """Configuration for wisdom signal propagation"""
    signal_types: List[WisdomSignalType] = field(default_factory=lambda: list(WisdomSignalType))
    base_diffusion_rate: float = 0.1
    base_decay_rate: float = 0.05
    intensity_threshold: float = 0.1
    cross_signal_interference: bool = True
    signal_amplification: Dict[WisdomSignalType, float] = field(default_factory=dict)
    debug: bool = False

# =====================================================================
# CORE SIGNAL PROPAGATION LOGIC
# =====================================================================

class WisdomSignalLayer:
    """
    Individual layer for a specific type of wisdom signal.
    Uses high-performance convolution for diffusion.
    """
    def __init__(self, width: int, height: int, signal_type: WisdomSignalType, config: WisdomSignalConfig):
        self.width = width
        self.height = height
        self.signal_type = signal_type
        self.config = config

        self.intensity_grid = np.zeros((height, width), dtype=np.float32)
        self.content_grid = [[None for _ in range(width)] for _ in range(height)]

        self.diffusion_rate = config.base_diffusion_rate
        self.decay_rate = config.base_decay_rate

        if signal_type in config.signal_amplification:
            self.diffusion_rate *= config.signal_amplification[signal_type]

        self._configure_signal_properties()
        self.diffusion_kernel = self._create_diffusion_kernel()

    def _create_diffusion_kernel(self) -> np.ndarray:
        """Creates a 3x3 kernel for convolutional diffusion."""
        kernel = np.ones((3, 3), dtype=np.float32) * self.diffusion_rate / 8.0
        kernel[1, 1] = 1.0 - self.diffusion_rate
        return kernel

    def _configure_signal_properties(self):
        """Configure signal properties based on wisdom signal type"""
        if self.signal_type == WisdomSignalType.SUFFERING_ALERT:
            self.diffusion_rate *= 1.5  # Spreads quickly
            self.decay_rate *= 0.5      # Persists longer
        elif self.signal_type == WisdomSignalType.WISDOM_BEACON:
            self.diffusion_rate *= 0.7  # Spreads slowly
            self.decay_rate *= 0.3      # Persists much longer
        elif self.signal_type == WisdomSignalType.MEDITATION_SYNC:
            self.diffusion_rate *= 2.0  # Spreads very quickly
            self.decay_rate *= 2.0      # Decays quickly
        elif self.signal_type == WisdomSignalType.COMPASSION_GRADIENT:
            self.diffusion_rate *= 1.2  # Moderate spread
            self.decay_rate *= 0.6      # Good persistence

    def add_signal(self, x: int, y: int, intensity: float,
                  insight: Optional[WisdomInsight] = None, agent_id: int = 0):
        """Add a wisdom signal at the specified location"""
        if insight and not isinstance(insight, WisdomInsight):
            raise TypeError(f"Provided insight must be of type WisdomInsight, not {type(insight)}")

        if 0 <= x < self.width and 0 <= y < self.height:
            self.intensity_grid[y, x] = min(1.0, self.intensity_grid[y, x] + intensity)
            if insight:
                self.content_grid[y][x] = insight

    def get_signal_gradient(self, x: int, y: int, radius: int = 1) -> Tuple[float, float]:
        """Get signal gradient (direction of strongest signal) at location."""
        if not (0 <= x < self.width and 0 <= y < self.height):
            return (0.0, 0.0)

        grad_x, grad_y = 0.0, 0.0
        center_intensity = self.intensity_grid[y, x]

        for dy_offset in range(-radius, radius + 1):
            for dx_offset in range(-radius, radius + 1):
                if dx_offset == 0 and dy_offset == 0: continue

                nx, ny = x + dx_offset, y + dy_offset
                if 0 <= nx < self.width and 0 <= ny < self.height:
                    neighbor_intensity = self.intensity_grid[ny, nx]
                    gradient = neighbor_intensity - center_intensity

                    length = np.sqrt(dx_offset**2 + dy_offset**2)
                    if length > 0:
                        grad_x += (dx_offset / length) * gradient
                        grad_y += (dy_offset / length) * gradient
        return (grad_x, grad_y)

    def update_diffusion(self, time_step: float = 1.0, environmental_modifier: float = 1.0):
        """Update signal diffusion using convolution and apply adaptive decay."""
        # 1. Diffusion via Convolution
        new_intensity = convolve2d(self.intensity_grid, self.diffusion_kernel, mode='same', boundary='wrap')

        # 2. Propagate Content (Optimized)
        spread_mask = (new_intensity > 0.3) & (self.intensity_grid < 0.3)
        for y, x in np.argwhere(spread_mask):
            max_intensity = -1.0
            source_content = None
            for dy in [-1, 0, 1]:
                for dx in [-1, 0, 1]:
                    if dx == 0 and dy == 0: continue
                    nx, ny = x - dx, y - dy
                    if 0 <= nx < self.width and 0 <= ny < self.height and self.intensity_grid[ny, nx] > max_intensity:
                        max_intensity = self.intensity_grid[ny, nx]
                        source_content = self.content_grid[ny][nx]
            if source_content and not self.content_grid[y][x]:
                self.content_grid[y][x] = source_content

        # 3. Apply Decay
        current_decay_rate = self.decay_rate * environmental_modifier
        new_intensity *= (1.0 - current_decay_rate * time_step)

        # 4. Cleanup
        np.clip(new_intensity, 0.0, 1.0, out=new_intensity)
        weak_mask = new_intensity < self.config.intensity_threshold
        new_intensity[weak_mask] = 0.0

        for y, x in np.argwhere(weak_mask):
            self.content_grid[y][x] = None

        self.intensity_grid = new_intensity

        if self.config.debug:
            max_intensity = np.max(self.intensity_grid)
            if max_intensity > self.config.intensity_threshold:
                logger.info(f"[DEBUG] Layer '{self.signal_type.value}': Max Intensity = {max_intensity:.4f}")

class WisdomSignalGrid:
    """Manages all signal layers and their interactions."""
    def __init__(self, width: int, height: int, config: WisdomSignalConfig,
                 interference_rules: Optional[Dict[Tuple[str, str], float]] = None):
        self.width = width
        self.height = height
        self.config = config

        self.signal_layers = {
            st: WisdomSignalLayer(width, height, st, config) for st in config.signal_types
        }

        self.interference_matrix = self._create_interference_matrix(interference_rules)

        logger.info(f"Initialized WisdomSignalGrid ({width}x{height}). Debug: {'ON' if config.debug else 'OFF'}")

    def _create_interference_matrix(self, custom_rules: Optional[Dict[Tuple[str, str], float]]) -> Dict[Tuple[WisdomSignalType, WisdomSignalType], float]:
        """Create matrix defining signal interference, with custom overrides."""
        interference = defaultdict(lambda: 1.0)
        rules = custom_rules or {
            ("meditation_sync", "wisdom_beacon"): 1.3,
            ("suffering_alert", "compassion_gradient"): 1.4,
            ("caution_warning", "cooperation_call"): 0.7,
        }

        for (s1_str, s2_str), factor in rules.items():
            s1 = WisdomSignalType(s1_str)
            s2 = WisdomSignalType(s2_str)
            interference[(s1, s2)] = factor
            interference[(s2, s1)] = factor
        return interference

    def add_signal(self, signal_type: WisdomSignalType, x: int, y: int, intensity: float,
                   insight: Optional[WisdomInsight] = None, agent_id: int = 0):
        """Add a signal to the appropriate grid layer."""
        if signal_type in self.signal_layers:
            self.signal_layers[signal_type].add_signal(x, y, intensity, insight, agent_id)

    def update_all_signals(self, time_step: float = 1.0,
                           env_modifiers: Optional[Dict[WisdomSignalType, float]] = None):
        """Update all signal layers."""
        env_modifiers = env_modifiers or {}
        for st, layer in self.signal_layers.items():
            modifier = env_modifiers.get(st, 1.0)
            layer.update_diffusion(time_step, environmental_modifier=modifier)

        if self.config.cross_signal_interference:
            self._apply_signal_interference()

    def _apply_signal_interference(self):
        """Apply interference between different signal types."""
        for (s1, s2), factor in self.interference_matrix.items():
            if factor == 1.0: continue
            layer1 = self.signal_layers[s1]
            layer2 = self.signal_layers[s2]

            overlap = (layer1.intensity_grid > 0.1) & (layer2.intensity_grid > 0.1)
            mod = layer1.intensity_grid[overlap] * (factor - 1.0)
            layer2.intensity_grid[overlap] += mod

        for layer in self.signal_layers.values():
            np.clip(layer.intensity_grid, 0.0, 1.0, out=layer.intensity_grid)

    def apply_overmind_modulation(self, feedback: Dict[WisdomSignalType, Dict[str, float]]):
        """Apply global modulation from a central controller."""
        if self.config.debug: logger.info(f"[DEBUG] Applying Overmind modulation: {feedback}")
        for st, mods in feedback.items():
            if st in self.signal_layers:
                layer = self.signal_layers[st]
                if "decay_rate_multiplier" in mods:
                    layer.decay_rate *= mods["decay_rate_multiplier"]
                if "diffusion_rate_multiplier" in mods:
                    layer.diffusion_rate *= mods["diffusion_rate_multiplier"]
                    layer.diffusion_kernel = layer._create_diffusion_kernel()

    def get_signals_at_location(self, x: int, y: int, radius: int = 1) -> Dict[WisdomSignalType, List[Tuple[WisdomInsight, float]]]:
        """Get all wisdom signals at a location."""
        signals = defaultdict(list)
        for r_y in range(-radius, radius + 1):
            for r_x in range(-radius, radius + 1):
                nx, ny = x + r_x, y + r_y
                if 0 <= nx < self.width and 0 <= ny < self.height:
                    for st, layer in self.signal_layers.items():
                        intensity = layer.intensity_grid[ny, nx]
                        content = layer.content_grid[ny][nx]
                        if intensity > self.config.intensity_threshold and content:
                            signals[st].append((content, intensity))
        return signals

    def get_signal_gradients(self, x: int, y: int) -> Dict[WisdomSignalType, Tuple[float, float]]:
        """Get signal gradients for all signal types at a location."""
        gradients = {}
        for signal_type, layer in self.signal_layers.items():
            gradients[signal_type] = layer.get_signal_gradient(x, y)
        return gradients

    # --- RESTORED NETWORK ANALYSIS TOOLS ---
    def detect_suffering_areas(self, threshold: float = 0.5) -> List[Tuple[int, int, float]]:
        """Detect areas with high suffering alert signals."""
        if WisdomSignalType.SUFFERING_ALERT not in self.signal_layers:
            return []

        suffering_layer = self.signal_layers[WisdomSignalType.SUFFERING_ALERT]
        # Find coordinates where intensity exceeds the threshold
        hotspot_coords = np.argwhere(suffering_layer.intensity_grid >= threshold)

        # Return a list of (x, y, intensity) tuples
        return [(x, y, suffering_layer.intensity_grid[y, x]) for y, x in hotspot_coords]

    def get_wisdom_hotspots(self, min_intensity: float = 0.6) -> Dict[WisdomSignalType, List[Tuple[int, int, float]]]:
        """Identify locations with high concentrations of any wisdom signal."""
        hotspots = defaultdict(list)
        for signal_type, layer in self.signal_layers.items():
            hotspot_coords = np.argwhere(layer.intensity_grid >= min_intensity)
            if hotspot_coords.size > 0:
                hotspots[signal_type] = [(x, y, layer.intensity_grid[y, x]) for y, x in hotspot_coords]
        return dict(hotspots)

    def visualize_signals(self) -> np.ndarray:
        """Create an RGB visualization of all signal grids combined."""
        vis = np.zeros((self.height, self.width, 3), dtype=np.float32)
        color_map = {
            WisdomSignalType.SUFFERING_ALERT: [1, 0, 0], WisdomSignalType.WISDOM_BEACON: [1, 1, 0],
            WisdomSignalType.COMPASSION_GRADIENT: [1, 0.5, 0], WisdomSignalType.MEDITATION_SYNC: [0, 0.5, 1],
            WisdomSignalType.COOPERATION_CALL: [0, 1, 0], WisdomSignalType.ETHICAL_INSIGHT: [1, 0, 1],
            WisdomSignalType.MINDFULNESS_WAVE: [0, 1, 1], WisdomSignalType.CAUTION_WARNING: [0.5, 0.5, 0.5],
        }
        for st, layer in self.signal_layers.items():
            color = np.array(color_map.get(st, [1,1,1]))
            vis += layer.intensity_grid[:, :, np.newaxis] * color
        return np.clip(vis, 0.0, 1.0)

    def get_network_stats(self) -> Dict[str, float]:
        """Get statistics about the wisdom signal network."""
        all_signals = []
        for layer in self.signal_layers.values():
            all_signals.append(layer.intensity_grid.flatten())

        if all_signals:
            combined = np.concatenate(all_signals)
            return {
                'signal_diversity': float(np.std(combined)),
                'network_coherence': float(np.mean(combined)),
                'total_signals': float(np.sum(combined > 0.1)),
                'max_intensity': float(np.max(combined)),
                'active_layers': sum(1 for layer in self.signal_layers.values() if np.any(layer.intensity_grid > 0.1))
            }
        return {
            'signal_diversity': 0.0,
            'network_coherence': 0.0,
            'total_signals': 0.0,
            'max_intensity': 0.0,
            'active_layers': 0
        }


# =====================================================================
# AGENT-LEVEL SIGNAL PROCESSOR (RESTORED AND INTEGRATED)
# =====================================================================

class WisdomSignalProcessor:
    """
    Processes wisdom signals for an individual agent, allowing it to
    react to the state of the wisdom grid.
    """
    def __init__(self, agent_id: int, signal_grid: WisdomSignalGrid, sensitivity_profile: Optional[Dict[WisdomSignalType, float]] = None):
        self.agent_id = agent_id
        self.signal_grid = signal_grid

        # --- RESTORED: Detailed and customizable sensitivities ---
        if sensitivity_profile:
            self.signal_sensitivity = sensitivity_profile
        else:
            # Default sensitivity profile
            self.signal_sensitivity = {
                WisdomSignalType.SUFFERING_ALERT: 0.9,
                WisdomSignalType.MEDITATION_SYNC: 0.8,
                WisdomSignalType.WISDOM_BEACON: 0.7,
                WisdomSignalType.COMPASSION_GRADIENT: 0.8,
                WisdomSignalType.ETHICAL_INSIGHT: 0.7,
                WisdomSignalType.COOPERATION_CALL: 0.6,
                WisdomSignalType.CAUTION_WARNING: 0.8,
                WisdomSignalType.MINDFULNESS_WAVE: 0.7
            }
        self.last_signals_received = {}

    def process_local_signals(self, x: int, y: int, radius: int = 2) -> Dict[str, Any]:
        """Process wisdom signals in the local area and recommend actions."""
        local_signals = self.signal_grid.get_signals_at_location(x, y, radius)
        signal_gradients = self.signal_grid.get_signal_gradients(x, y)

        processed_info = {
            'received_insights': [],
            'signal_influences': {},
            'recommended_actions': [],
            'emotional_state_modifiers': defaultdict(float) # Restored
        }

        for signal_type, signals in local_signals.items():
            sensitivity = self.signal_sensitivity.get(signal_type, 0.5)
            for insight, intensity in signals:
                adjusted_intensity = intensity * sensitivity
                if adjusted_intensity > 0.1: # Agent's perception threshold
                    processed_info['received_insights'].append({
                        'insight': insight,
                        'intensity': adjusted_intensity,
                        'signal_type': signal_type.name
                    })
                    self._generate_signal_response(signal_type, adjusted_intensity, processed_info)

        for signal_type, (dx, dy) in signal_gradients.items():
            strength = np.sqrt(dx**2 + dy**2)
            if strength > 0.05: # Gradient perception threshold
                processed_info['signal_influences'][signal_type.name] = {
                    'gradient_x': dx, 'gradient_y': dy, 'strength': strength
                }

        self.last_signals_received = processed_info
        return processed_info

    def _generate_signal_response(self, signal_type: WisdomSignalType, intensity: float, processed_info: Dict[str, Any]):
        """--- RESTORED: Generate a richer, more appropriate response to a specific signal type. ---"""
        if signal_type == WisdomSignalType.SUFFERING_ALERT:
            processed_info['recommended_actions'].append({'action': 'investigate_suffering', 'urgency': intensity})
            processed_info['emotional_state_modifiers']['compassion'] += intensity * 0.5
            processed_info['emotional_state_modifiers']['urgency'] += intensity * 0.3

        elif signal_type == WisdomSignalType.MEDITATION_SYNC:
            processed_info['recommended_actions'].append({'action': 'join_meditation', 'strength': intensity})
            processed_info['emotional_state_modifiers']['mindfulness'] += intensity * 0.6
            processed_info['emotional_state_modifiers']['inner_peace'] += intensity * 0.4

        elif signal_type == WisdomSignalType.COOPERATION_CALL:
            processed_info['recommended_actions'].append({'action': 'seek_collaboration', 'urgency': intensity})
            processed_info['emotional_state_modifiers']['social_orientation'] += intensity * 0.5

        elif signal_type == WisdomSignalType.WISDOM_BEACON:
            processed_info['recommended_actions'].append({'action': 'approach_wisdom_source', 'opportunity': intensity})
            processed_info['emotional_state_modifiers']['curiosity'] += intensity * 0.4

        elif signal_type == WisdomSignalType.CAUTION_WARNING:
            processed_info['recommended_actions'].append({'action': 'increase_caution', 'level': intensity})
            processed_info['emotional_state_modifiers']['caution'] += intensity * 0.6

    def emit_wisdom_signal(self, x: int, y: int, signal_type: WisdomSignalType,
                          intensity: float, insight: Optional[WisdomInsight] = None):
        """Emit a wisdom signal from the agent's current location."""
        self.signal_grid.add_signal(signal_type, x, y, intensity, insight=insight, agent_id=self.agent_id)
        if self.signal_grid.config.debug:
            logger.info(f"[DEBUG] Agent {self.agent_id} emitted {signal_type.name} at ({x},{y})")


# =====================================================================
# EXAMPLE USAGE
# =====================================================================

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(message)s')

    # 1. Create a configuration object
    config = WisdomSignalConfig(
        base_diffusion_rate=0.4,
        base_decay_rate=0.02,
        intensity_threshold=0.05,
        debug=False # Set to False for cleaner output, True for detailed logs
    )

    # 2. Initialize the Grid
    grid = WisdomSignalGrid(width=60, height=60, config=config)

    # 3. Create definitive, validated insights
    try:
        suffering_insight = WisdomInsight(
            wisdom_type=WisdomType.EMPATHIC_RESONANCE,
            content={'emotional_state': 'distress', 'target_entity': 'local_fauna', 'context': 'drought'},
            intensity=1.0, source_agent_id=1
        )
        system_insight = WisdomInsight(
            wisdom_type=WisdomType.SYSTEMIC_UNDERSTANDING,
            content={
                'system_name': 'ecosystem', 'key_relationships': ['water_cycle', 'plant_life'], 'leverage_points': ['water_conservation']
            },
            intensity=1.0, source_agent_id=2
        )
    except ValueError as e:
        logger.error(f"Insight creation failed: {e}")
        exit()

    # 4. Create Agent Processors with different sensitivities
    compassionate_agent_profile = {st: 0.5 for st in WisdomSignalType}
    compassionate_agent_profile[WisdomSignalType.SUFFERING_ALERT] = 1.2 # Extra sensitive to suffering
    compassionate_agent_profile[WisdomSignalType.COMPASSION_GRADIENT] = 1.2

    agent_1 = WisdomSignalProcessor(agent_id=1, signal_grid=grid, sensitivity_profile=compassionate_agent_profile)
    agent_2 = WisdomSignalProcessor(agent_id=2, signal_grid=grid) # Uses default sensitivities

    # 5. Agents emit initial signals
    agent_1.emit_wisdom_signal(x=15, y=15, signal_type=WisdomSignalType.SUFFERING_ALERT, intensity=1.0, insight=suffering_insight)
    agent_2.emit_wisdom_signal(x=45, y=45, signal_type=WisdomSignalType.WISDOM_BEACON, intensity=1.0, insight=system_insight)

    # 6. Simulate propagation
    print("\n--- Running Simulation ---")
    for i in range(1, 31):
        grid.update_all_signals()
        if i == 15:
            # Demonstrate network analysis mid-simulation
            print(f"\n--- Mid-Simulation Analysis (Step {i}) ---")
            suffering_areas = grid.detect_suffering_areas(threshold=0.4)
            if suffering_areas:
                print(f"Detected {len(suffering_areas)} points of high suffering.")
                # Agent 2 (the 'wise' one) processes this info and emits a compassion signal
                # This shows how analysis tools can drive agent behavior
                for sx, sy, s_intensity in suffering_areas[:1]: # React to the first detected point
                    print(f"Agent 2 is now aware of suffering at ({sx},{sy}) and emits a compassion gradient.")
                    agent_2.emit_wisdom_signal(sx, sy, WisdomSignalType.COMPASSION_GRADIENT, 0.8)
            else:
                print("No significant suffering areas detected yet.")

    print("\n--- Simulation Complete ---")

    # 7. Final Network Analysis
    print("\n--- Final Network Analysis ---")
    final_hotspots = grid.get_wisdom_hotspots(min_intensity=0.5)
    if final_hotspots:
        print(f"Found {len(final_hotspots)} types of wisdom hotspots.")
        for signal_type, spots in final_hotspots.items():
            print(f"  - {signal_type.name}: {len(spots)} hotspots.")
    else:
        print("No wisdom hotspots detected.")

    # 8. Visualize the final state
    try:
        import matplotlib.pyplot as plt
        visualization = grid.visualize_signals()
        plt.figure(figsize=(10, 10))
        plt.imshow(visualization)
        plt.title('Final Signal Grid State (Definitive Implementation)')
        plt.axis('off')
        plt.show()
    except ImportError:
        print("\nMatplotlib not found. Skipping visualization.")
        print("To see the visualization, run: pip install matplotlib scipy")